{"status": "success", "message": "Code analysis completed", "request_id": "8c031661-1e4c-4421-9aef-3f18a95755ba", "analysis": "I'll provide a comprehensive overview of Python function best practices. These guidelines will help you write more maintainable, readable, and efficient code.\n\n1. Function Naming\n- Use lowercase letters and underscores (snake_case)\n- Names should be descriptive and indicate what the function does\n- Use verbs for function names that perform actions\n\nGood examples:\n```python\ndef calculate_total():\n    pass\n\ndef get_user_data():\n    pass\n\ndef validate_email():\n    pass\n```\n\nBad examples:\n```python\ndef Total():  # Don't use CamelCase\n    pass\n\ndef x():  # Not descriptive\n    pass\n\ndef userData():  # Don't use camelCase\n    pass\n```\n\n2. Function Parameters\n- Keep the number of parameters minimal (ideally 4 or fewer)\n- Use default values for optional parameters\n- Use *args and **kwargs when needed for flexibility\n- Consider using type hints for better code documentation\n\n```python\ndef process_user_data(\n    name: str,\n    age: int,\n    email: str = None,\n    *args,\n    **kwargs\n) -> dict:\n    pass\n```\n\n3. Single Responsibility Principle\n- Each function should do one thing and do it well\n- If a function is doing multiple things, split it into smaller functions\n\nGood:\n```python\ndef validate_user_input(data):\n    pass\n\ndef process_user_input(data):\n    pass\n\ndef save_user_data(processed_data):\n    pass\n```\n\nBad:\n```python\ndef handle_user_data(data):\n    # Validates, processes, and saves data all in one function\n    # Too many responsibilities\n    pass\n```\n\n4. Documentation\n- Use docstrings to document your functions\n- Follow a consistent documentation style (e.g., Google style, NumPy style)\n- Include parameter types, return types, and examples when relevant\n\n```python\ndef calculate_discount(price: float, discount_percent: float) -> float:\n    \"\"\"\n    Calculate the final price after applying a discount.\n\n    Args:\n        price (float): Original price\n        discount_percent (float): Discount percentage (0-100)\n\n    Returns:\n        float: Final price after discount\n\n    Example:\n        >>> calculate_discount(100, 20)\n        80.0\n    \"\"\"\n    return price * (1 - discount_percent / 100)\n```\n\n5. Return Values\n- Be consistent with return types\n- Return early for edge cases\n- Avoid returning different types from the same function\n\nGood:\n```python\ndef get_user_status(user_id: int) -> str:\n    if not user_id:\n        return \"invalid_id\"\n    \n    if not is_user_exists(user_id):\n        return \"not_found\"\n    \n    return \"active\"\n```\n\nBad:\n```python\ndef get_user_status(user_id):\n    if not user_id:\n        return False  # Returns boolean\n    \n    if not is_user_exists(user_id):\n        return None  # Returns None\n    \n    return \"active\"  # Returns string\n```\n\n6. Error Handling\n- Use exceptions for error handling\n- Create custom exceptions when appropriate\n- Don't catch generic exceptions without a good reason\n\n```python\ndef divide_numbers(a: float, b: float) -> float:\n    if b == 0:\n        raise ValueError(\"Division by zero is not allowed\")\n    return a / b\n```\n\n7. Function Length\n- Keep functions short and focused (typically 20-30 lines maximum)\n- If a function is too long, consider breaking it into smaller functions\n- Use helper functions for repeated code\n\n8. Pure Functions\n- When possible, write pure functions (same output for same input)\n- Avoid side effects\n- Make functions independent of external state\n\nGood:\n```python\ndef calculate_area(width: float, height: float) -> float:\n    return width * height\n```\n\nBad:\n```python\ntotal = 0\n\ndef add_to_total(value):\n    global total\n    total += value  # Side effect: modifies global state\n    return total\n```\n\n9. Parameter Validation\n- Validate input parameters at the beginning of the function\n- Use assert statements or raise exceptions for invalid inputs\n- Consider using data validation libraries for complex validation\n\n```python\ndef create_user(username: str, age: int) -> dict:\n    if not isinstance(username, str):\n        raise TypeError(\"Username must be a string\")\n    \n    if not isinstance(age, int) or age < 0:\n        raise ValueError(\"Age must be a positive integer\")\n    \n    return {\"username\": username, \"age\": age}\n```\n\n10. Testing Considerations\n- Write functions that are easy to test\n- Avoid hard-coded dependencies\n- Use dependency injection when necessary\n- Keep functions pure when possible\n\n```python\n# Easy to test\ndef calculate_total(items: list, tax_rate: float) -> float:\n    return sum(items) * (1 + tax_rate)\n\n# Harder to test\ndef calculate_total_with_default_tax(items: list) -> float:\n    tax_rate = get_tax_rate_from_database()  # External dependency\n    return sum(items) * (1 + tax_rate)\n```\n\n11. Type Hints (Python 3.5+)\n- Use type hints to improve code readability and maintainability\n- Help catch type-related errors early\n- Improve IDE support and code analysis\n\n```python\nfrom typing import List, Dict, Optional\n\ndef process_users(\n    users: List[Dict[str, str]],\n    department: Optional[str] = None\n) -> List[str]:\n    pass\n```\n\n12. Function Arguments\n- Use keyword arguments for clarity\n- Consider using dataclasses or named tuples for multiple related parameters\n- Use default values appropriately\n\n```python\n# Using keyword arguments\ndef create_report(\n    title: str,\n    data: dict,\n    format: str = \"pdf\",\n    include_summary: bool = True\n):\n    pass\n\n# Calling the function\ncreate_report(\n    title=\"Monthly Report\",\n    data={\"sales\": 1000},\n    format=\"pdf\",\n    include_summary=True\n)\n```\n\nFollowing these best practices will help you write more maintainable, readable, and efficient Python code. Remember that these are guidelines rather than strict rules, and there may be situations where breaking them makes sense. The key is to understand the reasoning behind each practice and make informed decisions based on your specific use case.\n", "processing_time_seconds": 28.45, "input_prompt": "What are the best practices for Python functions?"}